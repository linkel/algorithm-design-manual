# Page 83


Following questions assume I have a self balancing dictionary data structure!

search, insert, delete, min, max, successor, predecessor

I have n numbers and I want to print them out in sorted order.

1. How can I sort in O(n log n) time using only insert and in order traversal?

To me, what I would want to do is grab that whole array of numbers and start INSERTING them into a new tree. We need to go thru all those numbers so that's O(n) for sure. But for each one, the insertion then is done in O(log n) time for each one so it's O(n) * O(log n). 

2. How can I sort in O(n log n) time using only min, successor, and insert?

I guess I can insert. That's O(n). Then I call min to get the tiniest. Then I have to call successor on the min, and successor on that successor, and so forth. So for each n I am doing a log n operation. Isn't this worse than the first? I guess the time complexity is the same though. 

3. How can I sort in O(n log n) time using only minimum, insert, delete, search?

So if I insert everything again. O(n) and log n. Now I can go to the minimum. Do I delete the min and find the min again? This seems bad. What about the search? 

It looks like that is the way to do it. Repeatedly finding and deleting the min element lol. Search was red herring? 
